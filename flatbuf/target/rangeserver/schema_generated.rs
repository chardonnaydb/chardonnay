// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod range_server {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATUS: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATUS: [Status; 12] = [
  Status::Ok,
  Status::InvalidRequestFormat,
  Status::RangeDoesNotExist,
  Status::RangeIsNotLoaded,
  Status::KeyIsOutOfRange,
  Status::RangeOwnershipLost,
  Status::Timeout,
  Status::InternalError,
  Status::TransactionAborted,
  Status::UnknownTransaction,
  Status::CacheIsFull,
  Status::PrefetchError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Status(pub i8);
#[allow(non_upper_case_globals)]
impl Status {
  pub const Ok: Self = Self(0);
  pub const InvalidRequestFormat: Self = Self(1);
  pub const RangeDoesNotExist: Self = Self(2);
  pub const RangeIsNotLoaded: Self = Self(3);
  pub const KeyIsOutOfRange: Self = Self(4);
  pub const RangeOwnershipLost: Self = Self(5);
  pub const Timeout: Self = Self(6);
  pub const InternalError: Self = Self(7);
  pub const TransactionAborted: Self = Self(8);
  pub const UnknownTransaction: Self = Self(9);
  pub const CacheIsFull: Self = Self(10);
  pub const PrefetchError: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Ok,
    Self::InvalidRequestFormat,
    Self::RangeDoesNotExist,
    Self::RangeIsNotLoaded,
    Self::KeyIsOutOfRange,
    Self::RangeOwnershipLost,
    Self::Timeout,
    Self::InternalError,
    Self::TransactionAborted,
    Self::UnknownTransaction,
    Self::CacheIsFull,
    Self::PrefetchError,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Ok => Some("Ok"),
      Self::InvalidRequestFormat => Some("InvalidRequestFormat"),
      Self::RangeDoesNotExist => Some("RangeDoesNotExist"),
      Self::RangeIsNotLoaded => Some("RangeIsNotLoaded"),
      Self::KeyIsOutOfRange => Some("KeyIsOutOfRange"),
      Self::RangeOwnershipLost => Some("RangeOwnershipLost"),
      Self::Timeout => Some("Timeout"),
      Self::InternalError => Some("InternalError"),
      Self::TransactionAborted => Some("TransactionAborted"),
      Self::UnknownTransaction => Some("UnknownTransaction"),
      Self::CacheIsFull => Some("CacheIsFull"),
      Self::PrefetchError => Some("PrefetchError"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Status {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Status {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Status {
    type Output = Status;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Status {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Status {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Status {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTRY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTRY: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTRY: [Entry; 3] = [
  Entry::Prepare,
  Entry::Commit,
  Entry::Abort,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Entry(pub i8);
#[allow(non_upper_case_globals)]
impl Entry {
  pub const Prepare: Self = Self(0);
  pub const Commit: Self = Self(1);
  pub const Abort: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Prepare,
    Self::Commit,
    Self::Abort,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Prepare => Some("Prepare"),
      Self::Commit => Some("Commit"),
      Self::Abort => Some("Abort"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Entry {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Entry {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Entry {
    type Output = Entry;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Entry {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Entry {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Entry {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 4] = [
  MessageType::Get,
  MessageType::Prepare,
  MessageType::Commit,
  MessageType::Abort,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub i8);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const Get: Self = Self(0);
  pub const Prepare: Self = Self(1);
  pub const Commit: Self = Self(2);
  pub const Abort: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Get,
    Self::Prepare,
    Self::Commit,
    Self::Abort,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Get => Some("Get"),
      Self::Prepare => Some("Prepare"),
      Self::Commit => Some("Commit"),
      Self::Abort => Some("Abort"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessageType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
pub enum Uuidu128Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uuidu128<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uuidu128<'a> {
  type Inner = Uuidu128<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Uuidu128<'a> {
  pub const VT_LOWER: flatbuffers::VOffsetT = 4;
  pub const VT_UPPER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Uuidu128 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Uuidu128Args
  ) -> flatbuffers::WIPOffset<Uuidu128<'bldr>> {
    let mut builder = Uuidu128Builder::new(_fbb);
    builder.add_upper(args.upper);
    builder.add_lower(args.lower);
    builder.finish()
  }


  #[inline]
  pub fn lower(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Uuidu128::VT_LOWER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn upper(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Uuidu128::VT_UPPER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Uuidu128<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("lower", Self::VT_LOWER, false)?
     .visit_field::<u64>("upper", Self::VT_UPPER, false)?
     .finish();
    Ok(())
  }
}
pub struct Uuidu128Args {
    pub lower: u64,
    pub upper: u64,
}
impl<'a> Default for Uuidu128Args {
  #[inline]
  fn default() -> Self {
    Uuidu128Args {
      lower: 0,
      upper: 0,
    }
  }
}

pub struct Uuidu128Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Uuidu128Builder<'a, 'b, A> {
  #[inline]
  pub fn add_lower(&mut self, lower: u64) {
    self.fbb_.push_slot::<u64>(Uuidu128::VT_LOWER, lower, 0);
  }
  #[inline]
  pub fn add_upper(&mut self, upper: u64) {
    self.fbb_.push_slot::<u64>(Uuidu128::VT_UPPER, upper, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Uuidu128Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    Uuidu128Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uuidu128<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Uuidu128<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Uuidu128");
      ds.field("lower", &self.lower());
      ds.field("upper", &self.upper());
      ds.finish()
  }
}
pub enum TransactionInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
  type Inner = TransactionInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransactionInfo<'a> {
  pub const VT_OVERALL_TIMEOUT_US: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionInfoArgs
  ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
    let mut builder = TransactionInfoBuilder::new(_fbb);
    builder.add_overall_timeout_us(args.overall_timeout_us);
    builder.finish()
  }


  #[inline]
  pub fn overall_timeout_us(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfo::VT_OVERALL_TIMEOUT_US, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TransactionInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("overall_timeout_us", Self::VT_OVERALL_TIMEOUT_US, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionInfoArgs {
    pub overall_timeout_us: u32,
}
impl<'a> Default for TransactionInfoArgs {
  #[inline]
  fn default() -> Self {
    TransactionInfoArgs {
      overall_timeout_us: 0,
    }
  }
}

pub struct TransactionInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_overall_timeout_us(&mut self, overall_timeout_us: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfo::VT_OVERALL_TIMEOUT_US, overall_timeout_us, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionInfo");
      ds.field("overall_timeout_us", &self.overall_timeout_us());
      ds.finish()
  }
}
pub enum RangeIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeId<'a> {
  type Inner = RangeId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RangeId<'a> {
  pub const VT_KEYSPACE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RANGE_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RangeIdArgs<'args>
  ) -> flatbuffers::WIPOffset<RangeId<'bldr>> {
    let mut builder = RangeIdBuilder::new(_fbb);
    if let Some(x) = args.range_id { builder.add_range_id(x); }
    if let Some(x) = args.keyspace_id { builder.add_keyspace_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn keyspace_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(RangeId::VT_KEYSPACE_ID, None)}
  }
  #[inline]
  pub fn range_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(RangeId::VT_RANGE_ID, None)}
  }
}

impl flatbuffers::Verifiable for RangeId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("keyspace_id", Self::VT_KEYSPACE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("range_id", Self::VT_RANGE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct RangeIdArgs<'a> {
    pub keyspace_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub range_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
}
impl<'a> Default for RangeIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    RangeIdArgs {
      keyspace_id: None,
      range_id: None,
    }
  }
}

pub struct RangeIdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RangeIdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_keyspace_id(&mut self, keyspace_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(RangeId::VT_KEYSPACE_ID, keyspace_id);
  }
  #[inline]
  pub fn add_range_id(&mut self, range_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(RangeId::VT_RANGE_ID, range_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RangeIdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RangeIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeId");
      ds.field("keyspace_id", &self.keyspace_id());
      ds.field("range_id", &self.range_id());
      ds.finish()
  }
}
pub enum EpochLeaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EpochLease<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EpochLease<'a> {
  type Inner = EpochLease<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EpochLease<'a> {
  pub const VT_LOWER_BOUND_INCLUSIVE: flatbuffers::VOffsetT = 4;
  pub const VT_UPPER_BOUND_INCLUSIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EpochLease { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EpochLeaseArgs
  ) -> flatbuffers::WIPOffset<EpochLease<'bldr>> {
    let mut builder = EpochLeaseBuilder::new(_fbb);
    builder.add_upper_bound_inclusive(args.upper_bound_inclusive);
    builder.add_lower_bound_inclusive(args.lower_bound_inclusive);
    builder.finish()
  }


  #[inline]
  pub fn lower_bound_inclusive(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(EpochLease::VT_LOWER_BOUND_INCLUSIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn upper_bound_inclusive(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(EpochLease::VT_UPPER_BOUND_INCLUSIVE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EpochLease<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("lower_bound_inclusive", Self::VT_LOWER_BOUND_INCLUSIVE, false)?
     .visit_field::<u64>("upper_bound_inclusive", Self::VT_UPPER_BOUND_INCLUSIVE, false)?
     .finish();
    Ok(())
  }
}
pub struct EpochLeaseArgs {
    pub lower_bound_inclusive: u64,
    pub upper_bound_inclusive: u64,
}
impl<'a> Default for EpochLeaseArgs {
  #[inline]
  fn default() -> Self {
    EpochLeaseArgs {
      lower_bound_inclusive: 0,
      upper_bound_inclusive: 0,
    }
  }
}

pub struct EpochLeaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EpochLeaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lower_bound_inclusive(&mut self, lower_bound_inclusive: u64) {
    self.fbb_.push_slot::<u64>(EpochLease::VT_LOWER_BOUND_INCLUSIVE, lower_bound_inclusive, 0);
  }
  #[inline]
  pub fn add_upper_bound_inclusive(&mut self, upper_bound_inclusive: u64) {
    self.fbb_.push_slot::<u64>(EpochLease::VT_UPPER_BOUND_INCLUSIVE, upper_bound_inclusive, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EpochLeaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EpochLeaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EpochLease<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EpochLease<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EpochLease");
      ds.field("lower_bound_inclusive", &self.lower_bound_inclusive());
      ds.field("upper_bound_inclusive", &self.upper_bound_inclusive());
      ds.finish()
  }
}
pub enum KeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Key<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Key<'a> {
  type Inner = Key<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Key<'a> {
  pub const VT_K: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Key { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyArgs<'args>
  ) -> flatbuffers::WIPOffset<Key<'bldr>> {
    let mut builder = KeyBuilder::new(_fbb);
    if let Some(x) = args.k { builder.add_k(x); }
    builder.finish()
  }


  #[inline]
  pub fn k(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Key::VT_K, None)}
  }
}

impl flatbuffers::Verifiable for Key<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("k", Self::VT_K, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyArgs<'a> {
    pub k: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for KeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyArgs {
      k: None,
    }
  }
}

pub struct KeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_k(&mut self, k: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Key::VT_K, k);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Key<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Key<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Key");
      ds.field("k", &self.k());
      ds.finish()
  }
}
pub enum RecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Record<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Record<'a> {
  type Inner = Record<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Record<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Record { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RecordArgs<'args>
  ) -> flatbuffers::WIPOffset<Record<'bldr>> {
    let mut builder = RecordBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<Key<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Key>>(Record::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Record::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Record<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Key>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct RecordArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<Key<'a>>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    RecordArgs {
      key: None,
      value: None,
    }
  }
}

pub struct RecordBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<Key<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Key>>(Record::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Record::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Record<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Record<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Record");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum GetRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRequest<'a> {
  type Inner = GetRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 6;
  pub const VT_TRANSACTION_INFO: flatbuffers::VOffsetT = 8;
  pub const VT_RANGE_ID: flatbuffers::VOffsetT = 10;
  pub const VT_KEYS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetRequest<'bldr>> {
    let mut builder = GetRequestBuilder::new(_fbb);
    if let Some(x) = args.keys { builder.add_keys(x); }
    if let Some(x) = args.range_id { builder.add_range_id(x); }
    if let Some(x) = args.transaction_info { builder.add_transaction_info(x); }
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(GetRequest::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn transaction_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(GetRequest::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn transaction_info(&self) -> Option<TransactionInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TransactionInfo>>(GetRequest::VT_TRANSACTION_INFO, None)}
  }
  #[inline]
  pub fn range_id(&self) -> Option<RangeId<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeId>>(GetRequest::VT_RANGE_ID, None)}
  }
  #[inline]
  pub fn keys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key>>>>(GetRequest::VT_KEYS, None)}
  }
}

impl flatbuffers::Verifiable for GetRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TransactionInfo>>("transaction_info", Self::VT_TRANSACTION_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeId>>("range_id", Self::VT_RANGE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Key>>>>("keys", Self::VT_KEYS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetRequestArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub transaction_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub transaction_info: Option<flatbuffers::WIPOffset<TransactionInfo<'a>>>,
    pub range_id: Option<flatbuffers::WIPOffset<RangeId<'a>>>,
    pub keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>>>,
}
impl<'a> Default for GetRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetRequestArgs {
      request_id: None,
      transaction_id: None,
      transaction_info: None,
      range_id: None,
      keys: None,
    }
  }
}

pub struct GetRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(GetRequest::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(GetRequest::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_transaction_info(&mut self, transaction_info: flatbuffers::WIPOffset<TransactionInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TransactionInfo>>(GetRequest::VT_TRANSACTION_INFO, transaction_info);
  }
  #[inline]
  pub fn add_range_id(&mut self, range_id: flatbuffers::WIPOffset<RangeId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeId>>(GetRequest::VT_RANGE_ID, range_id);
  }
  #[inline]
  pub fn add_keys(&mut self, keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Key<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRequest::VT_KEYS, keys);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetRequest");
      ds.field("request_id", &self.request_id());
      ds.field("transaction_id", &self.transaction_id());
      ds.field("transaction_info", &self.transaction_info());
      ds.field("range_id", &self.range_id());
      ds.field("keys", &self.keys());
      ds.finish()
  }
}
pub enum GetResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetResponse<'a> {
  type Inner = GetResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_LEADER_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 8;
  pub const VT_RECORDS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetResponse<'bldr>> {
    let mut builder = GetResponseBuilder::new(_fbb);
    builder.add_leader_sequence_number(args.leader_sequence_number);
    if let Some(x) = args.records { builder.add_records(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(GetResponse::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Status>(GetResponse::VT_STATUS, Some(Status::Ok)).unwrap()}
  }
  #[inline]
  pub fn leader_sequence_number(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GetResponse::VT_LEADER_SEQUENCE_NUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn records(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record>>>>(GetResponse::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for GetResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<Status>("status", Self::VT_STATUS, false)?
     .visit_field::<i64>("leader_sequence_number", Self::VT_LEADER_SEQUENCE_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Record>>>>("records", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetResponseArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub status: Status,
    pub leader_sequence_number: i64,
    pub records: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>>>,
}
impl<'a> Default for GetResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetResponseArgs {
      request_id: None,
      status: Status::Ok,
      leader_sequence_number: 0,
      records: None,
    }
  }
}

pub struct GetResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(GetResponse::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: Status) {
    self.fbb_.push_slot::<Status>(GetResponse::VT_STATUS, status, Status::Ok);
  }
  #[inline]
  pub fn add_leader_sequence_number(&mut self, leader_sequence_number: i64) {
    self.fbb_.push_slot::<i64>(GetResponse::VT_LEADER_SEQUENCE_NUMBER, leader_sequence_number, 0);
  }
  #[inline]
  pub fn add_records(&mut self, records: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Record<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetResponse::VT_RECORDS, records);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetResponse");
      ds.field("request_id", &self.request_id());
      ds.field("status", &self.status());
      ds.field("leader_sequence_number", &self.leader_sequence_number());
      ds.field("records", &self.records());
      ds.finish()
  }
}
pub enum PrepareRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepareRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepareRequest<'a> {
  type Inner = PrepareRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrepareRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 6;
  pub const VT_RANGE_ID: flatbuffers::VOffsetT = 8;
  pub const VT_HAS_READS: flatbuffers::VOffsetT = 10;
  pub const VT_PUTS: flatbuffers::VOffsetT = 12;
  pub const VT_DELETES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrepareRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrepareRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<PrepareRequest<'bldr>> {
    let mut builder = PrepareRequestBuilder::new(_fbb);
    if let Some(x) = args.deletes { builder.add_deletes(x); }
    if let Some(x) = args.puts { builder.add_puts(x); }
    if let Some(x) = args.range_id { builder.add_range_id(x); }
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.add_has_reads(args.has_reads);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(PrepareRequest::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn transaction_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(PrepareRequest::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn range_id(&self) -> Option<RangeId<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeId>>(PrepareRequest::VT_RANGE_ID, None)}
  }
  #[inline]
  pub fn has_reads(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PrepareRequest::VT_HAS_READS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn puts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record>>>>(PrepareRequest::VT_PUTS, None)}
  }
  #[inline]
  pub fn deletes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key>>>>(PrepareRequest::VT_DELETES, None)}
  }
}

impl flatbuffers::Verifiable for PrepareRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeId>>("range_id", Self::VT_RANGE_ID, false)?
     .visit_field::<bool>("has_reads", Self::VT_HAS_READS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Record>>>>("puts", Self::VT_PUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Key>>>>("deletes", Self::VT_DELETES, false)?
     .finish();
    Ok(())
  }
}
pub struct PrepareRequestArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub transaction_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub range_id: Option<flatbuffers::WIPOffset<RangeId<'a>>>,
    pub has_reads: bool,
    pub puts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>>>,
    pub deletes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>>>,
}
impl<'a> Default for PrepareRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrepareRequestArgs {
      request_id: None,
      transaction_id: None,
      range_id: None,
      has_reads: false,
      puts: None,
      deletes: None,
    }
  }
}

pub struct PrepareRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrepareRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(PrepareRequest::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(PrepareRequest::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_range_id(&mut self, range_id: flatbuffers::WIPOffset<RangeId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeId>>(PrepareRequest::VT_RANGE_ID, range_id);
  }
  #[inline]
  pub fn add_has_reads(&mut self, has_reads: bool) {
    self.fbb_.push_slot::<bool>(PrepareRequest::VT_HAS_READS, has_reads, false);
  }
  #[inline]
  pub fn add_puts(&mut self, puts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Record<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrepareRequest::VT_PUTS, puts);
  }
  #[inline]
  pub fn add_deletes(&mut self, deletes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Key<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrepareRequest::VT_DELETES, deletes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrepareRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrepareRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrepareRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrepareRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrepareRequest");
      ds.field("request_id", &self.request_id());
      ds.field("transaction_id", &self.transaction_id());
      ds.field("range_id", &self.range_id());
      ds.field("has_reads", &self.has_reads());
      ds.field("puts", &self.puts());
      ds.field("deletes", &self.deletes());
      ds.finish()
  }
}
pub enum PrepareResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepareResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepareResponse<'a> {
  type Inner = PrepareResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrepareResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_HIGHEST_KNOWN_EPOCH: flatbuffers::VOffsetT = 8;
  pub const VT_EPOCH_LEASE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrepareResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrepareResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<PrepareResponse<'bldr>> {
    let mut builder = PrepareResponseBuilder::new(_fbb);
    builder.add_highest_known_epoch(args.highest_known_epoch);
    if let Some(x) = args.epoch_lease { builder.add_epoch_lease(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(PrepareResponse::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Status>(PrepareResponse::VT_STATUS, Some(Status::Ok)).unwrap()}
  }
  #[inline]
  pub fn highest_known_epoch(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PrepareResponse::VT_HIGHEST_KNOWN_EPOCH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn epoch_lease(&self) -> Option<EpochLease<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EpochLease>>(PrepareResponse::VT_EPOCH_LEASE, None)}
  }
}

impl flatbuffers::Verifiable for PrepareResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<Status>("status", Self::VT_STATUS, false)?
     .visit_field::<u64>("highest_known_epoch", Self::VT_HIGHEST_KNOWN_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EpochLease>>("epoch_lease", Self::VT_EPOCH_LEASE, false)?
     .finish();
    Ok(())
  }
}
pub struct PrepareResponseArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub status: Status,
    pub highest_known_epoch: u64,
    pub epoch_lease: Option<flatbuffers::WIPOffset<EpochLease<'a>>>,
}
impl<'a> Default for PrepareResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrepareResponseArgs {
      request_id: None,
      status: Status::Ok,
      highest_known_epoch: 0,
      epoch_lease: None,
    }
  }
}

pub struct PrepareResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrepareResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(PrepareResponse::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: Status) {
    self.fbb_.push_slot::<Status>(PrepareResponse::VT_STATUS, status, Status::Ok);
  }
  #[inline]
  pub fn add_highest_known_epoch(&mut self, highest_known_epoch: u64) {
    self.fbb_.push_slot::<u64>(PrepareResponse::VT_HIGHEST_KNOWN_EPOCH, highest_known_epoch, 0);
  }
  #[inline]
  pub fn add_epoch_lease(&mut self, epoch_lease: flatbuffers::WIPOffset<EpochLease<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EpochLease>>(PrepareResponse::VT_EPOCH_LEASE, epoch_lease);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrepareResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrepareResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrepareResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrepareResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrepareResponse");
      ds.field("request_id", &self.request_id());
      ds.field("status", &self.status());
      ds.field("highest_known_epoch", &self.highest_known_epoch());
      ds.field("epoch_lease", &self.epoch_lease());
      ds.finish()
  }
}
pub enum CommitRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CommitRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommitRequest<'a> {
  type Inner = CommitRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommitRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 6;
  pub const VT_RANGE_ID: flatbuffers::VOffsetT = 8;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 10;
  pub const VT_VID: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommitRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommitRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CommitRequest<'bldr>> {
    let mut builder = CommitRequestBuilder::new(_fbb);
    builder.add_vid(args.vid);
    builder.add_epoch(args.epoch);
    if let Some(x) = args.range_id { builder.add_range_id(x); }
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(CommitRequest::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn transaction_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(CommitRequest::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn range_id(&self) -> Option<RangeId<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeId>>(CommitRequest::VT_RANGE_ID, None)}
  }
  #[inline]
  pub fn epoch(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CommitRequest::VT_EPOCH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vid(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CommitRequest::VT_VID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CommitRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeId>>("range_id", Self::VT_RANGE_ID, false)?
     .visit_field::<u64>("epoch", Self::VT_EPOCH, false)?
     .visit_field::<i64>("vid", Self::VT_VID, false)?
     .finish();
    Ok(())
  }
}
pub struct CommitRequestArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub transaction_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub range_id: Option<flatbuffers::WIPOffset<RangeId<'a>>>,
    pub epoch: u64,
    pub vid: i64,
}
impl<'a> Default for CommitRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommitRequestArgs {
      request_id: None,
      transaction_id: None,
      range_id: None,
      epoch: 0,
      vid: 0,
    }
  }
}

pub struct CommitRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommitRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(CommitRequest::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(CommitRequest::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_range_id(&mut self, range_id: flatbuffers::WIPOffset<RangeId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeId>>(CommitRequest::VT_RANGE_ID, range_id);
  }
  #[inline]
  pub fn add_epoch(&mut self, epoch: u64) {
    self.fbb_.push_slot::<u64>(CommitRequest::VT_EPOCH, epoch, 0);
  }
  #[inline]
  pub fn add_vid(&mut self, vid: i64) {
    self.fbb_.push_slot::<i64>(CommitRequest::VT_VID, vid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommitRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommitRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommitRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommitRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommitRequest");
      ds.field("request_id", &self.request_id());
      ds.field("transaction_id", &self.transaction_id());
      ds.field("range_id", &self.range_id());
      ds.field("epoch", &self.epoch());
      ds.field("vid", &self.vid());
      ds.finish()
  }
}
pub enum CommitResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CommitResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommitResponse<'a> {
  type Inner = CommitResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommitResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommitResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommitResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<CommitResponse<'bldr>> {
    let mut builder = CommitResponseBuilder::new(_fbb);
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(CommitResponse::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Status>(CommitResponse::VT_STATUS, Some(Status::Ok)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CommitResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<Status>("status", Self::VT_STATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CommitResponseArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub status: Status,
}
impl<'a> Default for CommitResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommitResponseArgs {
      request_id: None,
      status: Status::Ok,
    }
  }
}

pub struct CommitResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommitResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(CommitResponse::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: Status) {
    self.fbb_.push_slot::<Status>(CommitResponse::VT_STATUS, status, Status::Ok);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommitResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommitResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommitResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommitResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommitResponse");
      ds.field("request_id", &self.request_id());
      ds.field("status", &self.status());
      ds.finish()
  }
}
pub enum AbortRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AbortRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbortRequest<'a> {
  type Inner = AbortRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AbortRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 6;
  pub const VT_RANGE_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AbortRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AbortRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<AbortRequest<'bldr>> {
    let mut builder = AbortRequestBuilder::new(_fbb);
    if let Some(x) = args.range_id { builder.add_range_id(x); }
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(AbortRequest::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn transaction_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(AbortRequest::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn range_id(&self) -> Option<RangeId<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RangeId>>(AbortRequest::VT_RANGE_ID, None)}
  }
}

impl flatbuffers::Verifiable for AbortRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RangeId>>("range_id", Self::VT_RANGE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct AbortRequestArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub transaction_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub range_id: Option<flatbuffers::WIPOffset<RangeId<'a>>>,
}
impl<'a> Default for AbortRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AbortRequestArgs {
      request_id: None,
      transaction_id: None,
      range_id: None,
    }
  }
}

pub struct AbortRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AbortRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(AbortRequest::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(AbortRequest::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_range_id(&mut self, range_id: flatbuffers::WIPOffset<RangeId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RangeId>>(AbortRequest::VT_RANGE_ID, range_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AbortRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AbortRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbortRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AbortRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AbortRequest");
      ds.field("request_id", &self.request_id());
      ds.field("transaction_id", &self.transaction_id());
      ds.field("range_id", &self.range_id());
      ds.finish()
  }
}
pub enum AbortResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AbortResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbortResponse<'a> {
  type Inner = AbortResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AbortResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AbortResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AbortResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<AbortResponse<'bldr>> {
    let mut builder = AbortResponseBuilder::new(_fbb);
    if let Some(x) = args.request_id { builder.add_request_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> Option<Uuidu128<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Uuidu128>>(AbortResponse::VT_REQUEST_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Status>(AbortResponse::VT_STATUS, Some(Status::Ok)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AbortResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Uuidu128>>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<Status>("status", Self::VT_STATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct AbortResponseArgs<'a> {
    pub request_id: Option<flatbuffers::WIPOffset<Uuidu128<'a>>>,
    pub status: Status,
}
impl<'a> Default for AbortResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    AbortResponseArgs {
      request_id: None,
      status: Status::Ok,
    }
  }
}

pub struct AbortResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AbortResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: flatbuffers::WIPOffset<Uuidu128<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Uuidu128>>(AbortResponse::VT_REQUEST_ID, request_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: Status) {
    self.fbb_.push_slot::<Status>(AbortResponse::VT_STATUS, status, Status::Ok);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AbortResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AbortResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbortResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AbortResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AbortResponse");
      ds.field("request_id", &self.request_id());
      ds.field("status", &self.status());
      ds.finish()
  }
}
pub enum LogEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogEntry<'a> {
  type Inner = LogEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogEntry<'a> {
  pub const VT_ENTRY: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<LogEntry<'bldr>> {
    let mut builder = LogEntryBuilder::new(_fbb);
    if let Some(x) = args.bytes { builder.add_bytes(x); }
    builder.add_entry(args.entry);
    builder.finish()
  }


  #[inline]
  pub fn entry(&self) -> Entry {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Entry>(LogEntry::VT_ENTRY, Some(Entry::Prepare)).unwrap()}
  }
  #[inline]
  pub fn bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(LogEntry::VT_BYTES, None)}
  }
}

impl flatbuffers::Verifiable for LogEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Entry>("entry", Self::VT_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bytes", Self::VT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct LogEntryArgs<'a> {
    pub entry: Entry,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for LogEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogEntryArgs {
      entry: Entry::Prepare,
      bytes: None,
    }
  }
}

pub struct LogEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entry(&mut self, entry: Entry) {
    self.fbb_.push_slot::<Entry>(LogEntry::VT_ENTRY, entry, Entry::Prepare);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogEntry::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogEntry");
      ds.field("entry", &self.entry());
      ds.field("bytes", &self.bytes());
      ds.finish()
  }
}
pub enum RequestEnvelopeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RequestEnvelope<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RequestEnvelope<'a> {
  type Inner = RequestEnvelope<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RequestEnvelope<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RequestEnvelope { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestEnvelopeArgs<'args>
  ) -> flatbuffers::WIPOffset<RequestEnvelope<'bldr>> {
    let mut builder = RequestEnvelopeBuilder::new(_fbb);
    if let Some(x) = args.bytes { builder.add_bytes(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(RequestEnvelope::VT_TYPE_, Some(MessageType::Get)).unwrap()}
  }
  #[inline]
  pub fn bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RequestEnvelope::VT_BYTES, None)}
  }
}

impl flatbuffers::Verifiable for RequestEnvelope<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bytes", Self::VT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct RequestEnvelopeArgs<'a> {
    pub type_: MessageType,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RequestEnvelopeArgs<'a> {
  #[inline]
  fn default() -> Self {
    RequestEnvelopeArgs {
      type_: MessageType::Get,
      bytes: None,
    }
  }
}

pub struct RequestEnvelopeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestEnvelopeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: MessageType) {
    self.fbb_.push_slot::<MessageType>(RequestEnvelope::VT_TYPE_, type_, MessageType::Get);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RequestEnvelope::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestEnvelopeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestEnvelopeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RequestEnvelope<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RequestEnvelope<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RequestEnvelope");
      ds.field("type_", &self.type_());
      ds.field("bytes", &self.bytes());
      ds.finish()
  }
}
pub enum ResponseEnvelopeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResponseEnvelope<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResponseEnvelope<'a> {
  type Inner = ResponseEnvelope<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ResponseEnvelope<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResponseEnvelope { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponseEnvelopeArgs<'args>
  ) -> flatbuffers::WIPOffset<ResponseEnvelope<'bldr>> {
    let mut builder = ResponseEnvelopeBuilder::new(_fbb);
    if let Some(x) = args.bytes { builder.add_bytes(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(ResponseEnvelope::VT_TYPE_, Some(MessageType::Get)).unwrap()}
  }
  #[inline]
  pub fn bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ResponseEnvelope::VT_BYTES, None)}
  }
}

impl flatbuffers::Verifiable for ResponseEnvelope<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bytes", Self::VT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct ResponseEnvelopeArgs<'a> {
    pub type_: MessageType,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ResponseEnvelopeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResponseEnvelopeArgs {
      type_: MessageType::Get,
      bytes: None,
    }
  }
}

pub struct ResponseEnvelopeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponseEnvelopeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: MessageType) {
    self.fbb_.push_slot::<MessageType>(ResponseEnvelope::VT_TYPE_, type_, MessageType::Get);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ResponseEnvelope::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseEnvelopeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponseEnvelopeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResponseEnvelope<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResponseEnvelope<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResponseEnvelope");
      ds.field("type_", &self.type_());
      ds.field("bytes", &self.bytes());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LogEntry`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_log_entry_unchecked`.
pub fn root_as_log_entry(buf: &[u8]) -> Result<LogEntry, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LogEntry>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LogEntry` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_log_entry_unchecked`.
pub fn size_prefixed_root_as_log_entry(buf: &[u8]) -> Result<LogEntry, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LogEntry>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LogEntry` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_log_entry_unchecked`.
pub fn root_as_log_entry_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogEntry<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LogEntry<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LogEntry` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_log_entry_unchecked`.
pub fn size_prefixed_root_as_log_entry_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogEntry<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LogEntry<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LogEntry and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LogEntry`.
pub unsafe fn root_as_log_entry_unchecked(buf: &[u8]) -> LogEntry {
  flatbuffers::root_unchecked::<LogEntry>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LogEntry and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LogEntry`.
pub unsafe fn size_prefixed_root_as_log_entry_unchecked(buf: &[u8]) -> LogEntry {
  flatbuffers::size_prefixed_root_unchecked::<LogEntry>(buf)
}
#[inline]
pub fn finish_log_entry_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LogEntry<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_log_entry_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LogEntry<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod RangeServer

